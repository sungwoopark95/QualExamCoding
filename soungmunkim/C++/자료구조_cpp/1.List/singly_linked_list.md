# List

리스트(list, linear list)는 순서 있는 컬렉션이다. 집합에는 각 항목 간에 순서의 개념이 없으나 리스트에는 항목들 간에 순서가 있다. 또한 집합은 중복을 허용하지 않지만 리스트는 중복된 데이터의 저장이 가능하다.

1. 순차 리스트: 배열을 기반
2. 연결 리스트: 메모리의 동적할당을 기반


### 순차 리스트

- 장점
  1. 데이터의 참조가 쉬워 구현이 간단하다.
- 단점
  1. 크기가 고정된다
  2. 데이터 삽입/삭제시 기존 데이터를 이동해야한다.


### 연결 리스트

- 장점
  1. 연속적인 기억 공간 없이도 데이터를 저장하는 것이 가능하다.
  2. 기억 공간을 동적으로 활용하기 때문에 미리 기억 공간을 확보할 필요가 없다.
- 단점
  1. 링크 필드를 위한 추가 공간이 필요하다.
  2. 데이터의 참조와 구현이 순차 리스트에 비해 복잡하다.

## List의 ADT

 데이터가 순서대로 저장된다는 특징을 토대로 ADT를 정의한다.

---

### 객체

 n개의 E타입으로 구성된 순서 있는 컬렉션

### 연산

1. isEmpty() ::= 리스트가 공백 상태면 true를 반환
2. add(item) ::= 리스트에 item을 저장한다.
3. add(index, item) ::= 리스트 index위치에 item을 저장한다.
4. set(index, item) ::= 리스트 index위치에 있는 원소를 item으로 바꾼다.
5. remove(index) ::= index위치에 있는 원소를 삭제한다. 삭제된 데이터는 반환된다.
6. remove() ::= 최근에 반환된 원소를 삭제한다. 삭제된 데이터는 반환된다.
7. getItem(index) ::= index위치에 있는 원소를 반환한다.
8. getItem() ::= 현재 탐색 위치의 원소를 반환한다.
9. getSize() ::= 리스트에 저장되어 있는 원소의 수를 반환한다.
10. indexOf(item) ::= 리스트에서 item이 저장된 위치를 반환한다. 맨 처음에 있는 데이터의 위치가 반환된다.
11. lastIndexOf(item) ::= 리스트에서 item이 저장된 위치를 반환한다. 맨 뒤에 있는 데이터의 위치가 반환된다.
12. hasNext() ::= 아직 방문하지 않은 원소가 있으면 true를 반환한다.
13. first() ::= 처음 원소를 반환한다. 탐색 위치를 처음으로 설정한다.
14. next() ::= 다음 원소를 반환한다. 탐색 위치가 다음으로 하나 증가한다.
15. sort(int (*compare)(const void *, const void *)) ::= 정렬의 기준이 되는 함수를 등록하고 정렬한다. compare 함수는 첫번째 인자가 앞서는 특성이 있으면 음수를 반환하고 두번째 인자가 앞서는 특성이 있으면 양수를 반환한다. 두 인자가 같다면 0을 반환한다.
16. begin() ::== 처음 원소를 가리키는 iterator를 반환한다.
17. end() ::== 마지막 원소 다음을 가리키는 iterator를 반환한다.
18. erase(iterator) ::== 매개변수로 들어온 iterator가 가리키는 원소를 지우고 그 다음 원소를 가리키는 iterator를 반환한다.

---
